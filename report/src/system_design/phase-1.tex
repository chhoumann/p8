% Intro text - from data collection, but rewrite.
% Explain the overall design for the data collection phase by using diagrams of central components (DataCollector, etc.)
% Deep-dive into various aspects of the implementation, relying on the diagrams to explain the overall design

\section{Decoding Beacon Advertisement Packet: The KBeaconData Class}

As previously mentioned, we use Bluetooth Low Energy beacons that broadcast specific advertisement packets which can be perceived by other nearby devices.
The key element of these packets is a particular sequence of bytes encapsulating valuable information about the beacon and its broadcast. 
In this section, we delve into the details of this byte stream and present an analytical dissection of \texttt{KBeaconData}, a wrapper class whose purpose is to interpret and abstract over the byte stream.

\subsection{Beacon Advertisement Packet Structure}
% 4C-00-02-15-77-77-77-2E-6B-6B-6D-63-6E-2E-63-6F-6D-00-00-01-00-03-39-2B-C5
% Company ID:  4C-00
% Beacon type: 02-15
% UUID:        77-77-77-2E-6B-6B-6D-63-6E-2E-63-6F-6D-00-00-01
% Minor:       39-2B
% Major:       00-03
% TxPower:     C5
	 
Each beacon advertisement packet consists of a string of 25 bytes.
These bytes are distributed in a specific order, serving as unique identifiers and providing a variety of information about the beacon. 
The given byte stream is an example of an advertisement and can be represented as a sequence of hexadecimal values:


\noindent\texttt{4C-00-02-15-77-77-77-2E-6B-6B-6D-63-6E-2E-63-6F-6D-00-00-}


\noindent\texttt{00-03-39-2B-C5}


The allocation of bytes is as follows:

\begin{itemize}
  \item The initial two bytes, known as the Company ID (e.g., \texttt{4C-00}, i.e. Apple), uniquely identify the company that created the specification for the beacon.
  \item The next two bytes, known as the beacon type, represents the type of the beacon. For proximity beacons, like the ones we use, these two bytes must be set to \texttt{02-15}.
  \item The subsequent 16 bytes represent the \textit{Universally Unique Identifier} (UUID).
This UUID (e.g., \texttt{77-77-77-2E-6B-6B-6D-63-6E-2E-63-6F-6D-00-00-01}) is a standard identifier that the beacon broadcasts, allowing the receiving devices to recognize the specific beacon or a group of beacons.
  \item The next two bytes denote the Major number (e.g., \texttt{00-03}), and the two bytes following them indicate the Minor number (e.g., \texttt{39-2B}).
These two values allow further differentiation among beacons.
  \item The final byte, called TxPower (e.g., \texttt{C5}), indicates the \textit{Measured Power}, which represents a standardized signal strength value within Apple's proximity beacon technology. Obtained via a systematic procedure using an iPhone 5s, it involves sampling the Received Signal Strength Indicator (RSSI) from the beacon at a one-meter distance. Outliers in the RSSI samples are discarded to minimize signal strength variability. The remaining data is averaged, producing the 'Measured Power' - a benchmark for subsequent ranging calculations.
\end{itemize}
\cite{apple2023ibeacon}

\subsection{Role of the KBeaconData Class}

The KBeaconData class is a concrete class designed to parse and encapsulate the information embedded within the beacon advertisement packet.
As a wrapper class, it takes a byte array as an input and decodes the values, storing them in properties for subsequent use.
The implementation can be seen in code snippet \ref{lst:KBeaconData}.



\begin{figure}[h!]
\begin{lstlisting}[
	language=CSharp, 
	frame=single, 
	label={lst:KBeaconData},
	caption={C\# Implementation of the KBeaconData Class for processing Bluetooth Low Energy (BLE) Beacon Advertising Packets}, 
	captionpos=b] 
public sealed class KBeaconData {
private const int ByteCount = 25;

public Guid Uuid { get; }

public byte[] CompanyId { get; }

public ushort Major { get; }
public ushort Minor { get; }

public sbyte TxPower { get; }

public KBeaconData(byte[] data) 
	: this(data, BitConverter.IsLittleEndian) { }

public KBeaconData(byte[] data, bool isLittleEndian) {
	if (data.Length != ByteCount)
	throw new ArgumentException($"Number of bytes was {data.Length}, expected {ByteCount}.");

	if (isLittleEndian) {
	CompanyId = data.Take(2).ToArray();
	Uuid = new Guid(
		BitConverter.ToInt32(data.Skip(4).Take(4).ToArray()),
		BitConverter.ToInt16(data.Skip(8).Take(2).ToArray()),
		BitConverter.ToInt16(data.Skip(10).Take(2).ToArray()),
		data.Skip(12).Take(8).ToArray()
	);
	Major = BitConverter.ToUInt16(data.Skip(20).Take(2).ToArray());
	Minor = BitConverter.ToUInt16(data.Skip(22).Take(2).ToArray());
	} else {
	CompanyId = data.Take(2).ToArray();
	Uuid = new Guid(
		BitConverter.ToInt32(data.Skip(4).Take(4).Reverse().ToArray()),
		BitConverter.ToInt16(data.Skip(8).Take(2).Reverse().ToArray()),
		BitConverter.ToInt16(data.Skip(10).Take(2).Reverse().ToArray()),
		data.Skip(12).Take(8).ToArray()
	);
	Major = BitConverter.ToUInt16(
		data.Skip(20).Take(2).Reverse().ToArray()
	);
	Minor = BitConverter.ToUInt16(
		data.Skip(22).Take(2).Reverse().ToArray()
	);
	}
	TxPower = (sbyte)data[^1];
}
}
\end{lstlisting}
\end{figure}

The notion of endianness is crucial while interpreting the byte sequence.
It refers to the byte order in which the integers are stored in the computer memory. In the context of the KBeaconData class, the constructor accepts a boolean parameter that indicates whether the byte order of the data is little-endian or not. If the byte order is indeed little-endian, the sequence is read as-is. Otherwise, the sequence is reversed before interpreting, thereby maintaining the accuracy of the parsed data.

In both little and big-endian scenarios, the first two bytes are extracted as the Company ID.
However, the remaining data is parsed differently depending on the endianness. If the byte order is little-endian, the bytes are sequentially processed. The UUID is constructed from the next 16 bytes, with the first four bytes converted to an integer, the next four bytes to two short integers, and the last eight bytes remain as a byte array. The Major and Minor values are derived from the next two bytes each, interpreted as unsigned short integers. In case of big-endian, the sequence is reversed before parsing the UUID, Major, and Minor values.

The last byte, regardless of the endianness, is directly converted to a signed byte to represent the TxPower.


The KBeaconData class thereby provides an effecient way to parse, encapsulate, and interpret the data from beacon advertisement packets.

